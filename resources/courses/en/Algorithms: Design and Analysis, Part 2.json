{
    "source": "Coursera",
    "description": "In this course you will learn several fundamental principles of advanced algorithm design. You'll learn the greedy algorithm design paradigm, with applications to computing good network backbones (i.e., spanning trees) and good codes for data compression. You'll learn the tricky yet widely applicable dynamic programming algorithm design paradigm, with applications to routing in the Internet and sequencing genome fragments. &nbsp;You’ll learn what NP-completeness and the famous “P vs. NP” problem mean for the algorithm designer. &nbsp;Finally, we’ll study several strategies for dealing with hard (i.e., NP-complete problems), including the design and analysis of heuristics. &nbsp;Learn how shortest-path algorithms from the 1950s (i.e., pre-ARPANET!) govern the way that your Internet traffic gets routed today; why efficient algorithms are fundamental to modern genomics; and how to make a million bucks in prize money by “just” solving a math problem!\n In this course you will learn several fundamental principles of advanced algorithm design: greedy algorithms and applications; dynamic programming and applications; NP-completeness and what it means for the algorithm designer; the design and analysis of heuristics; and more.",
    "contents": "Weeks 1 and 2: The greedy algorithm design paradigm.&nbsp; Applications to optimal caching and scheduling.&nbsp; Minimum spanning trees and applications to clustering.&nbsp; The union-find data structure.&nbsp; Optimal data compression.Weeks 3 and 4: The dynamic programming design paradigm.&nbsp; Applications to the knapsack problem,&nbsp;sequence alignment, shortest-path routing, and optimal search trees.Weeks 5 and 6: Intractable problems and what to do about them.&nbsp; NP-completeness and the P vs. NP question.&nbsp; Solvable special cases. Heuristics with provable performance guarantees.&nbsp; Local search.&nbsp;Exponential-time algorithms that beat brute-force search.",
    "requirements": "How to program in at least one programming language (like C, Java, or Python); and familiarity with proofs, including proofs by induction and by contradiction. &nbsp;At Stanford, a version of this course is taken by sophomore, junior, and senior-level computer science majors. &nbsp;The course assumes familiarity with some of&nbsp;the topics from Algo 1&nbsp;--- especially asymptotic analysis, basic data structures, and basic graph algorithms.\n",
    "effort": "6-10 hours\/week",
    "language": "en",
    "url": "https:\/\/www.coursera.org\/course\/algo2",
    "title": "Algorithms: Design and Analysis, Part 2",
    "courseraId": "128",
    "subjects": "Computer Science: Theory"
}